---
phase: 19-justfile-hero-image-support
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [scripts/publish.sh]
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "heroImage field preserved when post has hero image value"
    - "Empty heroImage/heroImageAlt/heroImageCaption fields stripped correctly"
    - "Build succeeds after publishing post with hero image"
  artifacts:
    - path: "scripts/publish.sh"
      provides: "Correct perl regex quoting in normalize_frontmatter()"
      contains: "perl -pe 's/^heroImage"
  key_links:
    - from: "scripts/publish.sh"
      to: "perl regex engine"
      via: "single-quoted regex pattern"
      pattern: "perl -pe 's/"
---

<objective>
Fix shell variable interpolation bug in publish.sh normalize_frontmatter() that strips heroImage key from frontmatter.

Purpose: UAT revealed that lines 278, 281, 284 use double quotes around perl regex patterns containing `$\n`, which bash interprets as an empty variable followed by `\n` rather than the intended regex anchor+newline. This causes the heroImage KEY to be stripped while leaving the VALUE orphaned, breaking YAML parsing.

Output: publish.sh with correct single-quoted perl regex patterns that preserve heroImage fields when they have values, while correctly stripping empty fields.
</objective>

<execution_context>
@/home/jc/.claude/get-shit-done/workflows/execute-plan.md
@/home/jc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/19-justfile-hero-image-support/19-UAT.md

# The bug is in normalize_frontmatter() function
@scripts/publish.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix perl regex quoting in normalize_frontmatter()</name>
  <files>scripts/publish.sh</files>
  <action>
In the normalize_frontmatter() function, change the three perl regex commands from double quotes to single quotes:

Line 278 (heroImage):
Before: content=$(echo "$content" | perl -pe 's/^heroImage:\s*$\n?//m')
After:  content=$(echo "$content" | perl -pe 's/^heroImage:\s*$\n?//m')

Line 281 (heroImageAlt):
Before: content=$(echo "$content" | perl -pe 's/^heroImageAlt:\s*$\n?//m')
After:  content=$(echo "$content" | perl -pe 's/^heroImageAlt:\s*$\n?//m')

Line 284 (heroImageCaption):
Before: content=$(echo "$content" | perl -pe 's/^heroImageCaption:\s*$\n?//m')
After:  content=$(echo "$content" | perl -pe 's/^heroImageCaption:\s*$\n?//m')

The key change: Replace the outer double quotes (") with single quotes (') around the perl -pe argument.

Why this works:
- Double quotes: bash expands $\n as empty variable + literal \n
- Single quotes: bash passes $\n literally to perl, where $ means end-of-line anchor in regex

The regex `s/^heroImage:\s*$\n?//m` should only match lines where heroImage: is followed by optional whitespace and then END OF LINE (empty value), optionally consuming the trailing newline. With double quotes, the `$` gets eaten by bash, so the regex becomes `s/^heroImage:\s*\n?//m` which matches heroImage: followed by anything before the newline, including actual values.
  </action>
  <verify>
1. Check the fix is applied:
   grep -n "perl -pe 's/^heroImage" scripts/publish.sh
   Should show single quotes around the perl argument on all three lines

2. Test with a post that has a hero image:
   Create test frontmatter:
   echo -e "---\nheroImage: test.jpg\nheroImageAlt: Test alt\n---" | perl -pe 's/^heroImage:\s*$\n?//m'
   Should output the same content unchanged (heroImage has a value, not empty)

3. Test with empty heroImage:
   echo -e "---\nheroImage:\ntitle: Test\n---" | perl -pe 's/^heroImage:\s*$\n?//m'
   Should strip the empty heroImage: line
  </verify>
  <done>
- perl regex patterns use single quotes
- Posts with heroImage values preserve the field
- Posts with empty heroImage have the field stripped
- Build succeeds for posts with hero images
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify fix with publish dry-run</name>
  <files>scripts/publish.sh</files>
  <action>
Run the publish workflow in dry-run mode to verify the fix works end-to-end:

1. Find a post in the Obsidian vault that has a heroImage field with a value
2. Run: ./scripts/publish.sh --dry-run --all
3. Verify no YAML parse errors occur
4. Check the normalized frontmatter would preserve heroImage field

If no post with heroImage exists, create a temporary test:
- Add heroImage: Attachments/test.jpg to a draft post's frontmatter
- Run dry-run
- Verify heroImage preserved in output
- Remove test heroImage if added
  </action>
  <verify>
./scripts/publish.sh --dry-run --all 2>&1 | grep -i "error\|heroImage"
Should show no YAML errors, and if verbose, show heroImage being processed correctly
  </verify>
  <done>
- Publish workflow completes dry-run without YAML parse errors
- heroImage field values are preserved in published frontmatter
  </done>
</task>

</tasks>

<verification>
1. Regex quoting: `grep "perl -pe" scripts/publish.sh` shows single quotes
2. Unit test empty field removal: `echo -e "---\nheroImage:\n---" | perl -pe 's/^heroImage:\s*$\n?//m'` outputs just `---\n---`
3. Unit test value preservation: `echo -e "---\nheroImage: foo.jpg\n---" | perl -pe 's/^heroImage:\s*$\n?//m'` outputs unchanged
4. Integration: `./scripts/publish.sh --dry-run --all` succeeds without YAML errors
</verification>

<success_criteria>
- [ ] Lines 278, 281, 284 use single quotes around perl -pe argument
- [ ] Posts with heroImage values build successfully
- [ ] Empty heroImage/heroImageAlt/heroImageCaption fields are stripped
- [ ] UAT test #1 (Hero Image Alt Change Detection) can pass
</success_criteria>

<output>
After completion, create `.planning/phases/19-justfile-hero-image-support/19-02-SUMMARY.md`
</output>
